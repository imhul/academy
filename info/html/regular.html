<!Doctype html>
<html lang="ru">
	<head>
		<meta charset="utf-8">
		<title>Регулярные выражения</title>
        <style>
		</style>
	</head>

<body>
   <div id="block"></div>
   <script>
       // Perl Compatible Regular Expressions (pcre)
       
    //    var re = new RegExp('pattern', 'options'); // или var re = /pattern/options; или var re = /pattern/;
    //    re = /some/;   
    //    var txt = 'some text 1';
    //    var index = txt.search(re); // Метод, возвращающий позицию первой найденной подстроки (при отсутствии искомого, возвращает -1)
    //    console.log(index);
       
       // Опции поиска(options): могут быть написаны в любом порядке после /pattern/
       // i игнорирование регистр
       // m многострочный поиск
       // g глобальный поиск всех вхождений (для метода match)
       
       // Символ ^ означает начало строки 
       // Символ $ означает крнец строки 
       // Символ * означает, что предыдущий символ повторяется 0 или более раз. Тоже что и  {0,}
       // Символ + означает, что предыдущий символ повторяется 1 или более раз. Тоже что и {1,}
       // Символ ? означает повторение предыдущего символа 0 или 1 раз. Тоже что и  {0,1}
       // Символ . означает любой символ кроме символа новой строки
       // Символ \ экранирующий символ для поиска зарезервированных спецсимволов
       // Символ \n символ перевода строки
       // Символ \t символ табуляции
       // Символ \s означает любой пробельный символ
       // Символ \S означает любой непробельный символ
       // Символ \d любая цифра. Тоже что и [0-9]
       // Символ \D любая нецифра
       // Символ \w любые латинские буквы, цифры и подчеркивание
       // Символ \W обратное \w То же, что и [^a-zA-Z0-9_]
       // Символ \b Позиция между словом и пробелом
       // Символ \B обратное \b
       // Символ | означает ЛИБО, например 2|3 означает либо 2 либо 3
       // Символ () запоминает найденное соответствие для дальнейшего использования, либо используется для группировки искомого
       // Если в скобках вначале стоит ?: запоминание не происходит
       // ?= возвращает искомое, только если после него стоит другое искомое, например: /iphone(?=4s|5s|6s)/ вернёт iphone если после него стоит 4s или 5s или 6s
       // ?! тоже что и ?= только в случае несоответствия
       // Метод match возвращает массив найденных подстрок, если включена опция g!!!
       
       //var arr = txt.match(re); 
       // без опции глобального поиска возвращает массив в котором элемент с индексом 0 - первая найденная подстрока
       // index позиция найденной подстроки
       // input исходная строка
       //console.log(arr);
       
       // {n} ровно n раз
       // {n,} от n до бесконечности
       // {n,m} от n до m
       // [] означает любой символ в квадратных скобках, например [a-zA-Z0-9_], тоже что и \w
       // [^abc] означает любой символ, кроме a,b,c
       
       // Метод replace находит и меняет строку или подстроку
       // Если есть опция глобального поиска, ищет все подстроки и меняет их, без этой опции находит и меняет первое найденное
       // Можно использовать в виде функции
       
       //var newTxt = txt.replace(re, 'то, чем нужно заменить искомое');
       // Или
       //var newTxt = txt.replace(re, function(){
       //       console.log(arguments);
       //       return 'то, чем нужно заменить искомое'}); 
       // Результат такой же, как у match без глобального поиска
       
       // Свойство глобального объекта RegExp: то, что запомнили скобки(), вызывается знаком $ и цифрой, 
       // означающей порядковый номер скобок: ()()() - $1 $2 $3
       
       // В HTML5 регулярные выражения можно записывать в атрибут pattern, например: pattern="^[a-z]+[a-z0-9]+{0,9}$"
       
       ////////////////////////////////////////////////////////////
       
       //var re = new RegExp('pattern', 'options');
        var re = /([\+-]?[\d\.]+)\u00B0C/img;
        var str = 'Buy new iPhone6s for 1000$ today! I have old Iphone4s. +20°C jfghskjfhg -5.5°C u209450924 0°C wor96u029 -100°C 4u5092u3';
        var newStr = str.replace(re, function(substr, temp){
            temp = temp * 1.8 + 32;
            return temp + '°F';
        });
        console.log(newStr);
        
        ///////////////////////////////////////////////////////////
        /saj/.test('jghjhgsajfgjhgf'); // true
        /rrr/.test('jghjhgsajfgjhgf'); // false
        ///////////////////////////////////////////////////////////
        
   </script>
</body>
</html>